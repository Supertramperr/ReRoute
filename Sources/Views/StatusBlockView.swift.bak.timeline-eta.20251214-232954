import SwiftUI
import Foundation

// MARK: - Generic internet pill (works with any status type)
struct InternetPill<S>: View {
    let status: S

    private var statusString: String {
        String(describing: status)
    }

    private var isOnline: Bool {
        let s = statusString.lowercased()
        if s.contains("online") { return true }
        if s.contains("up") { return true }
        if s.contains("reachable") { return true }
        return false
    }

    private var title: String {
        // Prefer clean names if the enum prints "online"/"offline"
        let s = statusString
        if s.lowercased().contains("offline") { return "Offline" }
        if isOnline { return "Online" }
        return s
    }

    var body: some View {
        Text(title)
            .font(.system(size: 11, weight: .semibold))
            .padding(.horizontal, 10)
            .padding(.vertical, 5)
            .background(
                Capsule(style: .continuous)
                    .fill(Color.white.opacity(isOnline ? 0.14 : 0.10))
            )
            .overlay(
                Capsule(style: .continuous)
                    .strokeBorder(Color.white.opacity(isOnline ? 0.18 : 0.12), lineWidth: 1)
            )
            .opacity(isOnline ? 1.0 : 0.95)
    }
}

// MARK: - Starting shimmer bar (full-width animated track)
struct StartingShimmerBar: View {
    private let height: CGFloat = 8
    @State private var t: CGFloat = 0

    var body: some View {
        GeometryReader { geo in
            let w = max(1, geo.size.width)
            let highlightW = max(36, w * 0.28)

            ZStack(alignment: .leading) {
                Capsule()
                    .fill(Color.white.opacity(0.06))
                    .overlay(
                        Capsule().strokeBorder(Color.white.opacity(0.10), lineWidth: 1)
                    )

                Capsule()
                    .fill(
                        LinearGradient(
                            stops: [
                                .init(color: .clear, location: 0.00),
                                .init(color: Color.white.opacity(0.22), location: 0.50),
                                .init(color: .clear, location: 1.00),
                            ],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .frame(width: highlightW, height: height)
                    .offset(x: (t * (w + highlightW)) - highlightW)
                    .blendMode(.screen)
                    .opacity(0.9)
            }
            .onAppear {
                t = 0
                withAnimation(.linear(duration: 1.2).repeatForever(autoreverses: false)) {
                    t = 1
                }
            }
        }
        .frame(height: height)
        .frame(maxWidth: .infinity)
    }
}

// MARK: - Custom progress bar (completely empty at 0%)
struct ReRouteProgressBar: View {
    let value: Double
    let total: Double

    private let height: CGFloat = 8

    private var ratio: Double {
        guard total > 0 else { return 0 }
        return min(max(value / total, 0), 1)
    }

    var body: some View {
        GeometryReader { geo in
            let w = geo.size.width
            let fillW = max(0, w * ratio)

            ZStack(alignment: .leading) {
                Capsule()
                    .fill(Color.white.opacity(0.10))
                    .overlay(
                        Capsule().strokeBorder(Color.white.opacity(0.10), lineWidth: 1)
                    )

                Capsule()
                    .fill(Color.accentColor.opacity(0.95))
                    .frame(width: fillW)
                    .opacity(ratio <= 0.00001 ? 0 : 1) // no "nub" at 0%
            }
        }
        .frame(height: height)
        .clipShape(Capsule())
    }
}

// MARK: - Status block
struct StatusBlockView: View {
    @EnvironmentObject var model: AppModel

    // Progress reset after success
    @State private var resetToken = UUID()
    private let progressResetDelaySeconds: Double = 5

    // ETA ticking
    @State private var now = Date()
    @State private var etaStart: Date? = nil
    private let tick = Timer.publish(every: 1, on: .main, in: .common).autoconnect()

    // Average duration (seconds) used for ETA countdown
    // Adjust here to your measured average.
    private let estimatedTotalSeconds: Double = 106

    private var pct: Int { Int((model.progress * 100).rounded()) }

    private var showETA: Bool {
        model.progress > 0.001 && model.progress < 0.999
    }
    private var remainingSeconds: Int {
        // Countdown is time-based (not progress-based), so it updates live.
        guard let start = etaStart else { return Int(estimatedTotalSeconds) }
        let elapsed = now.timeIntervalSince(start)
        return max(0, Int(ceil(estimatedTotalSeconds - elapsed)))
    }

    private var operationText: String {
        // Avoid depending on a specific API like `.label`
        String(describing: model.operation)
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            HStack {
                Text("Status").font(.headline)
                Spacer()
                InternetPill(status: model.internet)
            }

            HStack {
                Text("Operation:").foregroundStyle(.secondary)
                Text(operationText).fontWeight(.semibold)
                Spacer()
            }

            VStack(alignment: .leading, spacing: 6) {
                HStack {
                    Text("Progress:").foregroundStyle(.secondary)
                    Spacer()
                    Text("\(pct)%")
                        .font(.system(.body, design: .monospaced))
                        .foregroundStyle(.secondary)
                }

                if String(describing: model.operation).lowercased().contains("starting") {
                    StartingShimmerBar()
                        .frame(maxWidth: .infinity)
                } else {
                    ReRouteProgressBar(value: model.progress, total: 1)
                        .frame(maxWidth: .infinity)
                }

                if showETA {
                    Text("Est. remaining: \(remainingSeconds)s")
                        .font(.system(size: 11))
                        .opacity(0.72)
                }
            }

            if let lastReboot = model.lastReboot {
                Text("Last reboot: \(relative(lastReboot))")
                    .font(.footnote)
                    .foregroundStyle(.secondary)
            }

            if case .failed(let msg) = model.operation {
                Text("Failed: \(msg)")
                    .font(.footnote)
                    .foregroundStyle(.red)
                    .lineLimit(2)
            } else if let err = model.lastError {
                Text("Failed: \(err)")
                    .font(.footnote)
                    .foregroundStyle(.red)
                    .lineLimit(2)
            }
        }
        .padding(12)
        .background(.regularMaterial)
        .clipShape(RoundedRectangle(cornerRadius: 14, style: .continuous))
        .overlay(
            RoundedRectangle(cornerRadius: 14, style: .continuous)
                .strokeBorder(Color.white.opacity(0.12), lineWidth: 1)
        )
        .onReceive(tick) { now = $0 }
        .onChange(of: model.progress) { newValue in
            // Start ETA clock only when progress begins to move
            if newValue > 0.001 && etaStart == nil { etaStart = Date() }
            // Reset ETA clock when progress is cleared
            if newValue <= 0.001 { etaStart = nil }

            // Cancel pending reset if we moved away from completion
            if newValue < 0.999 { resetToken = UUID() }

            scheduleProgressResetIfNeeded()
        }
    }

    private func scheduleProgressResetIfNeeded() {
        guard model.progress >= 0.999 else { return }

        let token = UUID()
        resetToken = token

        DispatchQueue.main.asyncAfter(deadline: .now() + progressResetDelaySeconds) {
            guard self.resetToken == token else { return }
            if self.model.progress >= 0.999 {
                self.model.progress = 0.0
            }
        }
    }

    private func relative(_ date: Date) -> String {
        let f = RelativeDateTimeFormatter()
        f.unitsStyle = .abbreviated
        return f.localizedString(for: date, relativeTo: Date())
    }
}
